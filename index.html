<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paste Clean — Fix What You Paste</title>
    <meta name="description" content="Smart paste cleaner. Pick where you copied from, where you're pasting to — get perfectly cleaned text.">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/turndown/dist/turndown.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/turndown-plugin-gfm/dist/turndown-plugin-gfm.js"></script>
    <script>
        // Apply theme before paint to prevent flash
        (function() {
            const saved = localStorage.getItem('pasteclean-theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            if (saved === 'dark' || (!saved && prefersDark)) {
                document.documentElement.classList.add('dark');
            }
        })();

        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        accent: '#6c63ff',
                        accentHover: '#7b73ff',
                    }
                }
            }
        }
    </script>
    <style>
        * { box-sizing: border-box; }
        textarea { resize: none; }
        textarea:focus, button:focus { outline: none; }
        .tab-active { background: #6c63ff; color: white; }

        /* Light theme tabs */
        .tab-inactive { background: #f3f4f6; color: #6b7280; }
        .tab-inactive:hover { background: #e5e7eb; color: #374151; }
        /* Dark theme tabs */
        html.dark .tab-inactive { background: #1f2937; color: #9ca3af; }
        html.dark .tab-inactive:hover { background: #374151; color: #e5e7eb; }

        .copy-flash { animation: flash 0.6s ease-out; }
        @keyframes flash { 0% { background: #6c63ff; } 100% { background: transparent; } }
        ::selection { background: #6c63ff44; }
        @keyframes slideDown {
            from { opacity: 0; max-height: 0; padding-top: 0; padding-bottom: 0; margin-bottom: 0; }
            to { opacity: 1; max-height: 60px; padding-top: 0.5rem; padding-bottom: 0.5rem; margin-bottom: 0.75rem; }
        }
        @keyframes slideUp {
            from { opacity: 1; max-height: 60px; }
            to { opacity: 0; max-height: 0; padding-top: 0; padding-bottom: 0; margin-bottom: 0; }
        }
        .banner-enter { animation: slideDown 0.3s ease-out forwards; overflow: hidden; }
        .banner-exit { animation: slideUp 0.2s ease-in forwards; overflow: hidden; }

        /* HTML preview — follows app theme; override inline colors from formatters in dark mode */
        html.dark .html-preview * { color: inherit !important; }
        .html-preview h1 { font-size: 1.5em; font-weight: bold; margin: 0.5em 0; }
        .html-preview h2 { font-size: 1.3em; font-weight: bold; margin: 0.5em 0; }
        .html-preview h3 { font-size: 1.1em; font-weight: bold; margin: 0.5em 0; }
        .html-preview p { margin: 0.4em 0; }
        .html-preview ul { list-style: disc; padding-left: 1.5em; margin: 0.4em 0; }
        .html-preview ol { list-style: decimal; padding-left: 1.5em; margin: 0.4em 0; }
        .html-preview li { margin: 0.2em 0; }
        .html-preview code { background: #f0f0f0; padding: 0.15em 0.4em; border-radius: 3px; font-size: 0.9em; }
        .html-preview pre { background: #f0f0f0; padding: 1em; border-radius: 6px; overflow-x: auto; margin: 0.5em 0; }
        .html-preview pre code { background: none; padding: 0; }
        html.dark .html-preview code { background: #1f2937; }
        html.dark .html-preview pre { background: #1f2937; }
        .html-preview blockquote { border-left: 3px solid #ccc; padding-left: 1em; color: #555; margin: 0.5em 0; }
        html.dark .html-preview blockquote { color: #9ca3af; }
        .html-preview a { color: #1a73e8; text-decoration: underline; }
        html.dark .html-preview a { color: #818cf8; }
        .html-preview strong { font-weight: bold; }
        .html-preview em { font-style: italic; }
        .html-preview table { border-collapse: collapse; margin: 0.5em 0; width: 100%; }
        .html-preview th, .html-preview td { border: 1px solid #ccc; padding: 0.4em 0.8em; text-align: left; }
        html.dark .html-preview th, html.dark .html-preview td { border-color: #374151; }
        .html-preview th { background: #f5f5f5; font-weight: 600; }
        html.dark .html-preview th { background: #1f2937; }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center px-4 py-8 md:py-12 bg-white dark:bg-gray-950 text-gray-900 dark:text-gray-100 transition-colors">

    <!-- Header -->
    <div class="w-full max-w-3xl mb-8">
        <div class="flex items-center gap-3 mb-2">
            <h1 class="text-2xl md:text-3xl font-bold tracking-tight">Paste Clean</h1>
            <span class="text-xs px-2 py-0.5 rounded-full bg-gray-100 dark:bg-gray-800 border border-gray-200 dark:border-gray-700 text-gray-500 dark:text-gray-400">beta</span>
            <div class="flex-1"></div>
            <button onclick="toggleTheme()" id="theme-toggle" class="p-2 rounded-lg text-gray-400 dark:text-gray-500 hover:text-gray-600 dark:hover:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-800 transition-all" title="Toggle dark/light mode">
                <!-- Sun icon (shown in dark mode) -->
                <svg id="icon-sun" class="w-5 h-5 hidden" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><circle cx="12" cy="12" r="5"/><path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/></svg>
                <!-- Moon icon (shown in light mode) -->
                <svg id="icon-moon" class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>
            </button>
        </div>
        <p class="text-gray-500 dark:text-gray-400 text-sm md:text-base">Stop reformatting text every time you move it between apps.</p>
    </div>

    <!-- Input tabs (source) -->
    <div class="w-full max-w-3xl mb-1">
        <span class="text-xs text-gray-400 dark:text-gray-500 mb-1.5 block">Copied from:</span>
        <div class="flex flex-wrap gap-1.5">
            <button onclick="setInputMode('general')" id="in-general" class="tab-active px-3 py-1.5 rounded-lg text-sm font-medium transition-all">General</button>
            <button onclick="setInputMode('outlook')" id="in-outlook" class="tab-inactive px-3 py-1.5 rounded-lg text-sm font-medium transition-all">Outlook</button>
            <button onclick="setInputMode('gmail')" id="in-gmail" class="tab-inactive px-3 py-1.5 rounded-lg text-sm font-medium transition-all">Gmail</button>
            <button onclick="setInputMode('word')" id="in-word" class="tab-inactive px-3 py-1.5 rounded-lg text-sm font-medium transition-all">Word</button>
            <button onclick="setInputMode('pdf')" id="in-pdf" class="tab-inactive px-3 py-1.5 rounded-lg text-sm font-medium transition-all">PDF</button>
            <button onclick="setInputMode('excel')" id="in-excel" class="tab-inactive px-3 py-1.5 rounded-lg text-sm font-medium transition-all">Excel / Sheets</button>
            <button onclick="setInputMode('markdown')" id="in-markdown" class="tab-inactive px-3 py-1.5 rounded-lg text-sm font-medium transition-all">Markdown</button>
        </div>
    </div>

    <!-- Auto-detect suggestion banner -->
    <div id="suggestion-banner" class="w-full max-w-3xl hidden">
        <div class="flex items-center gap-3 bg-indigo-50 dark:bg-gray-800 border border-indigo-200 dark:border-gray-600 rounded-lg px-4 py-2 text-sm">
            <span id="suggestion-text" class="text-gray-600 dark:text-gray-300 flex-1"></span>
            <button onclick="acceptSuggestion()" id="suggestion-accept" class="px-3 py-1 rounded-md text-xs font-medium bg-accent text-white hover:bg-accentHover transition-all">Switch</button>
            <button onclick="dismissSuggestion()" class="px-3 py-1 rounded-md text-xs font-medium text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 transition-all">Dismiss</button>
        </div>
    </div>

    <!-- Input -->
    <div class="w-full max-w-3xl mb-3 mt-3">
        <div class="relative">
            <textarea
                id="input"
                class="w-full h-48 bg-gray-50 dark:bg-gray-900 border border-gray-200 dark:border-gray-700 rounded-xl p-4 text-gray-900 dark:text-gray-100 text-sm font-mono placeholder-gray-400 dark:placeholder-gray-600 focus:border-accent transition-colors"
                placeholder="Paste your text here..."
            ></textarea>
        </div>
    </div>

    <!-- Output tabs (destination) -->
    <div class="w-full max-w-3xl mb-1 flex items-center gap-2 flex-wrap">
        <span class="text-xs text-gray-400 dark:text-gray-500 mr-1">Pasting to:</span>
        <button onclick="setOutputMode('markdown')" id="out-markdown" class="tab-active px-3 py-1.5 rounded-lg text-xs font-medium transition-all">Markdown</button>
        <button onclick="setOutputMode('outlook')" id="out-outlook" class="tab-inactive px-3 py-1.5 rounded-lg text-xs font-medium transition-all">Outlook</button>
        <button onclick="setOutputMode('gmail')" id="out-gmail" class="tab-inactive px-3 py-1.5 rounded-lg text-xs font-medium transition-all">Gmail</button>
        <button onclick="setOutputMode('word')" id="out-word" class="tab-inactive px-3 py-1.5 rounded-lg text-xs font-medium transition-all">Word</button>
        <button onclick="setOutputMode('whatsapp')" id="out-whatsapp" class="tab-inactive px-3 py-1.5 rounded-lg text-xs font-medium transition-all">WhatsApp</button>
    </div>

    <!-- Font/size overrides (shown for Word/Outlook/Gmail output) -->
    <div id="font-overrides" class="w-full max-w-3xl mb-3 mt-2 hidden">
        <div class="flex items-center gap-3 text-xs">
            <span class="text-gray-400 dark:text-gray-500">Font:</span>
            <select id="font-family" onchange="renderOutput()" class="bg-gray-50 dark:bg-gray-900 border border-gray-200 dark:border-gray-700 text-gray-700 dark:text-gray-300 rounded-md px-2 py-1 text-xs">
                <option value="">Match app default</option>
                <option value="Calibri,sans-serif">Calibri</option>
                <option value="Arial,sans-serif">Arial</option>
                <option value="Aptos,sans-serif">Aptos</option>
                <option value="Times New Roman,serif">Times New Roman</option>
                <option value="Verdana,sans-serif">Verdana</option>
                <option value="Segoe UI,sans-serif">Segoe UI</option>
            </select>
            <span class="text-gray-400 dark:text-gray-500">Size:</span>
            <select id="font-size" onchange="renderOutput()" class="bg-gray-50 dark:bg-gray-900 border border-gray-200 dark:border-gray-700 text-gray-700 dark:text-gray-300 rounded-md px-2 py-1 text-xs">
                <option value="">Match app default</option>
                <option value="10pt">10pt</option>
                <option value="11pt">11pt</option>
                <option value="12pt">12pt</option>
                <option value="14pt">14pt</option>
            </select>
        </div>
    </div>

    <!-- Output -->
    <div class="w-full max-w-3xl mb-3">
        <textarea
            id="output-text"
            class="w-full h-48 bg-gray-50 dark:bg-gray-900 border border-gray-200 dark:border-gray-700 rounded-xl p-4 text-gray-900 dark:text-gray-100 text-sm font-mono placeholder-gray-400 dark:placeholder-gray-600 focus:border-accent transition-colors"
            placeholder="Cleaned text appears here..."
        ></textarea>
        <div id="output-html-wrap" class="hidden">
            <div id="output-html" class="w-full min-h-[12rem] bg-gray-50 dark:bg-gray-900 border border-gray-200 dark:border-gray-700 rounded-xl p-4 text-sm text-gray-900 dark:text-gray-100 html-preview"></div>
        </div>
        <p id="output-hint" class="hidden text-xs text-gray-400 dark:text-gray-500 mt-2"></p>
    </div>

    <!-- Actions (below output for easy reach on mobile) -->
    <div class="w-full max-w-3xl mb-6 flex items-center gap-2">
        <div class="flex-1"></div>
        <button onclick="clearAll()" class="px-4 py-2 rounded-lg text-sm font-medium bg-gray-100 dark:bg-gray-800 border border-gray-200 dark:border-gray-700 text-gray-500 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-gray-700 hover:text-gray-700 dark:hover:text-gray-200 transition-all">
            Clear
        </button>
        <button onclick="copyOutput()" id="btn-copy" class="px-4 py-2 rounded-lg text-sm font-medium bg-accent text-white hover:bg-accentHover transition-all">
            Copy
        </button>
    </div>

    <!-- Stats -->
    <div id="stats" class="w-full max-w-3xl mb-8 hidden">
        <div class="flex gap-4 text-xs text-gray-400 dark:text-gray-500">
            <span id="stat-mode"></span>
            <span id="stat-changes"></span>
        </div>
    </div>

    <!-- Footer -->
    <div class="w-full max-w-3xl mt-auto pt-8 border-t border-gray-200 dark:border-gray-800">
        <div class="flex flex-col md:flex-row justify-between items-center gap-2 text-xs text-gray-400 dark:text-gray-500">
            <span>Built by <a href="https://github.com/coder-kuttappan" class="text-accent hover:underline">Coder Kuttappan</a></span>
            <span id="paste-counter" class="tabular-nums"></span>
            <span>All processing happens in your browser. Nothing is sent anywhere.</span>
        </div>
    </div>

<script>
// ============================================================================
// CONFIG
// ============================================================================

const INPUT_MODES = ['general', 'outlook', 'gmail', 'word', 'pdf', 'excel', 'markdown'];
const OUTPUT_MODES = ['markdown', 'outlook', 'gmail', 'word', 'whatsapp'];

// Input→Output conflicts: when input is X, hide X from output
const INPUT_OUTPUT_CONFLICTS = {
    outlook: ['outlook'],
    gmail: ['gmail'],
    word: ['word'],
    markdown: ['markdown'],
};

const INPUT_LABELS = {
    general: 'General',
    outlook: 'Outlook',
    gmail: 'Gmail',
    word: 'Word',
    pdf: 'PDF',
    excel: 'Excel / Sheets',
    markdown: 'Markdown',
};

const OUTPUT_LABELS = {
    markdown: 'Markdown',
    outlook: 'Outlook',
    gmail: 'Gmail',
    word: 'Word',
    whatsapp: 'WhatsApp',
};

// ============================================================================
// STATE
// ============================================================================

let currentInputMode = 'general';
let currentOutputMode = 'markdown';
let pastedHTML = '';
let pastedPlain = '';
let intermediateMarkdown = '';
let formattedOutput = '';
let formattedHTML = '';
let suggestedMode = null;
let suggestionDismissed = false;

// ============================================================================
// THEME
// ============================================================================

function toggleTheme() {
    const isDark = document.documentElement.classList.toggle('dark');
    localStorage.setItem('pasteclean-theme', isDark ? 'dark' : 'light');
    updateThemeIcons();
}

function updateThemeIcons() {
    const isDark = document.documentElement.classList.contains('dark');
    document.getElementById('icon-sun').classList.toggle('hidden', !isDark);
    document.getElementById('icon-moon').classList.toggle('hidden', isDark);
}

// Listen for system theme changes (only if no manual override)
window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
    if (!localStorage.getItem('pasteclean-theme')) {
        document.documentElement.classList.toggle('dark', e.matches);
        updateThemeIcons();
    }
});

// ============================================================================
// UI — MODE SWITCHING
// ============================================================================

function setInputMode(mode) {
    currentInputMode = mode;
    suggestionDismissed = false;
    suggestedMode = null;
    hideSuggestionBanner();

    INPUT_MODES.forEach(m => {
        const el = document.getElementById(`in-${m}`);
        el.className = m === mode
            ? 'tab-active px-3 py-1.5 rounded-lg text-sm font-medium transition-all'
            : 'tab-inactive px-3 py-1.5 rounded-lg text-sm font-medium transition-all';
    });

    applyOutputConstraints();
    runPipeline();
}

function setOutputMode(mode) {
    currentOutputMode = mode;

    // Style ALL tabs including hidden ones — so when a hidden tab is later
    // unhidden (constraint change), it doesn't still have tab-active styling
    OUTPUT_MODES.forEach(m => {
        const el = document.getElementById(`out-${m}`);
        const isHidden = el.classList.contains('hidden');
        el.className = m === mode
            ? 'tab-active px-3 py-1.5 rounded-lg text-xs font-medium transition-all'
            : 'tab-inactive px-3 py-1.5 rounded-lg text-xs font-medium transition-all';
        if (isHidden) el.classList.add('hidden');
    });

    // Show font overrides for Word/Outlook/Gmail
    const fontRow = document.getElementById('font-overrides');
    if (mode === 'word' || mode === 'outlook' || mode === 'gmail') {
        fontRow.classList.remove('hidden');
        // Reset to "Match app default" when switching output tabs
        document.getElementById('font-family').value = '';
        document.getElementById('font-size').value = '';
    } else {
        fontRow.classList.add('hidden');
    }

    renderOutput();
}

function applyOutputConstraints() {
    const conflicts = INPUT_OUTPUT_CONFLICTS[currentInputMode] || [];
    let needSwitch = false;

    OUTPUT_MODES.forEach(m => {
        const el = document.getElementById(`out-${m}`);
        if (conflicts.includes(m)) {
            el.classList.add('hidden');
            if (currentOutputMode === m) needSwitch = true;
        } else {
            el.classList.remove('hidden');
        }
    });

    if (needSwitch) {
        // Find first visible output mode
        const firstVisible = OUTPUT_MODES.find(m => !conflicts.includes(m));
        setOutputMode(firstVisible || 'markdown');
    }
}

// ============================================================================
// UI — AUTO-DETECT SUGGESTION BANNER
// ============================================================================

function showSuggestionBanner(detected) {
    if (detected === currentInputMode || suggestionDismissed) return;
    suggestedMode = detected;
    const banner = document.getElementById('suggestion-banner');
    const text = document.getElementById('suggestion-text');
    text.textContent = `This looks like ${INPUT_LABELS[detected]} text.`;
    document.getElementById('suggestion-accept').textContent = `Switch to ${INPUT_LABELS[detected]}`;
    banner.classList.remove('hidden', 'banner-exit');
    banner.classList.add('banner-enter');
}

function hideSuggestionBanner() {
    const banner = document.getElementById('suggestion-banner');
    if (!banner.classList.contains('hidden')) {
        banner.classList.remove('banner-enter');
        banner.classList.add('banner-exit');
        setTimeout(() => {
            banner.classList.add('hidden');
            banner.classList.remove('banner-exit');
        }, 200);
    }
}

function acceptSuggestion() {
    if (suggestedMode) {
        setInputMode(suggestedMode);
    }
}

function dismissSuggestion() {
    suggestionDismissed = true;
    hideSuggestionBanner();
}

// ============================================================================
// AUTO-DETECT — Source detection from HTML and plain text signals
// ============================================================================

function detectSource(html, plain) {
    if (html) {
        // 1. Explicit app namespaces (highest confidence)
        if (/xmlns:x="urn:schemas-microsoft-com:office:excel"|ProgId.*Excel/i.test(html)) {
            return 'excel';
        }

        // 2. Gmail: check before MSO because Gmail can wrap Outlook-authored emails
        if (/class="?gmail_|data-smartmail|googlequote/i.test(html)) {
            return 'gmail';
        }

        // 3. Word vs Outlook (both produce MSO markup)
        if (/class="?Mso|<o:p>|xmlns:o="urn:schemas-microsoft-com/i.test(html)) {
            if (/class="?MsoHeading|class="?MsoToc|ProgId.*Word/i.test(html)) {
                return 'word';
            }
            return 'outlook';
        }

        // 4. Generic HTML email (marketing newsletters, transactional emails)
        // Must check BEFORE table heuristic — email HTML is full of layout tables
        if (looksLikeEmailHtml(html)) {
            return 'gmail';  // Best generic email handler
        }

        // 5. Table-dominant content (spreadsheet) — only if not email
        if (/<table[\s>]/i.test(html) && (/<tr[\s>].*<tr[\s>]/is.test(html))) {
            const cellCount = (html.match(/<td[\s>]/gi) || []).length;
            const paraCount = (html.match(/<p[\s>]/gi) || []).length;
            if (cellCount >= 4 && cellCount > paraCount * 2) return 'excel';
        }
    }

    if (plain) {
        const trimmed = plain.trim();
        const lines = trimmed.split('\n');

        const tsvLines = lines.filter(l => l.includes('\t') && l.split('\t').length >= 3);
        if (lines.length >= 2 && tsvLines.length / lines.length > 0.5) {
            return 'excel';
        }

        const mdSignals = [
            /^#{1,6}\s/m, /\*\*[^*]+\*\*/, /^\s*[-*+]\s/m,
            /^\s*\d+\.\s/m, /\[.+\]\(.+\)/, /^```/m, /^>\s/m,
        ];
        if (mdSignals.filter(r => r.test(trimmed)).length >= 2) {
            return 'markdown';
        }

        // PDF detection: mid-sentence line breaks continuing lowercase
        const pdfSignals = lines.filter((l, i) => {
            if (i >= lines.length - 1) return false;
            const next = lines[i + 1];
            return l.length > 20 && l.length < 80 &&
                   !/[.!?:;]$/.test(l) &&
                   next && /^[a-z]/.test(next.trim());
        });
        // Isolated page numbers
        const pageNumbers = lines.filter(l => /^\s*\d{1,4}\s*$/.test(l) || /^\s*page\s+\d+/i.test(l));
        // Consistent short line lengths (column-width text)
        const nonEmptyLines = lines.filter(l => l.trim().length > 0);
        const lineLengths = nonEmptyLines.map(l => l.length);
        const medianLen = lineLengths.slice().sort((a, b) => a - b)[Math.floor(lineLengths.length / 2)] || 0;
        const shortConsistent = medianLen >= 35 && medianLen <= 75 &&
            nonEmptyLines.filter(l => Math.abs(l.length - medianLen) < 15).length / nonEmptyLines.length > 0.5;
        // Hyphenation across line breaks
        const hyphenBreaks = (plain.match(/\w-\n\s*[a-z]/g) || []).length;

        let pdfScore = pdfSignals.length / Math.max(lines.length, 1);
        if (pageNumbers.length >= 2) pdfScore += 0.15;
        if (shortConsistent) pdfScore += 0.1;
        if (hyphenBreaks >= 3) pdfScore += 0.1;

        if (lines.length >= 4 && pdfScore > 0.3) {
            return 'pdf';
        }

        if (/\u00E2\u20AC[\u201C\u201D\u2122\u02DC\u0153\u009D\u00A2\u00A6]|\u00C2[\u00A0\u00A3\u00A9\u00AE\u00B0\u00B7\u00BD]/.test(trimmed)) {
            return 'outlook';
        }
    }

    return null;
}

function looksLikeEmailHtml(html) {
    const signals = [
        /unsubscribe/i,
        /email\s*preferences/i,
        /view\s*(this\s*)?(email|in\s*browser)/i,
        /role="presentation"/i,
        /<table[^>]*width\s*=\s*["']?(600|640|660|700|800)["']?/i,
        /<center>/i,
        /<!--\[if\s/i,
        /max-width:\s*(600|640|660|700|800)px/i,
    ];
    return signals.filter(r => r.test(html)).length >= 2;
}

// ============================================================================
// INPUT NORMALIZERS
// ============================================================================

function normalizeGeneral(text) {
    let r = text;
    r = fixMojibake(r);
    r = r.replace(/[\u200B\u200C\u200D\uFEFF]/g, '');
    r = r.replace(/\u00A0/g, ' ');
    r = r.split('\n').map(line => {
        const m = line.match(/^(\s*)(.*)/);
        return m[1] + m[2].replace(/ {2,}/g, ' ');
    }).join('\n');
    r = r.split('\n').map(l => l.trimEnd()).join('\n');
    r = r.replace(/\n{3,}/g, '\n\n');
    return r.trim();
}

function normalizeHtmlGeneral(html) {
    const cleaned = cleanEmailHtml(html);
    const md = htmlToMarkdown(cleaned);
    return normalizeGeneral(md);
}

function cleanEmailHtml(html) {
    let doc = new DOMParser().parseFromString(html, 'text/html');

    // Remove script, style, head elements
    doc.querySelectorAll('script, style, head, link, meta').forEach(el => el.remove());

    // Remove tracking pixels and tiny/invisible images
    doc.querySelectorAll('img').forEach(img => {
        const w = parseInt(img.getAttribute('width') || '999', 10);
        const h = parseInt(img.getAttribute('height') || '999', 10);
        const src = img.getAttribute('src') || '';
        if (w <= 3 || h <= 3) { img.remove(); return; }
        if (/track|pixel|beacon|open[._-]|click[._-]|\.gif\?/i.test(src) && !img.alt) {
            img.remove(); return;
        }
    });

    // Remove hidden elements
    doc.querySelectorAll('[style]').forEach(el => {
        const style = el.getAttribute('style') || '';
        if (/display\s*:\s*none|visibility\s*:\s*hidden|font-size\s*:\s*0/i.test(style)) {
            el.remove();
        }
    });
    doc.querySelectorAll('[hidden]').forEach(el => el.remove());

    // Unwrap layout tables (role=presentation, single-column, or width-constrained email wrappers)
    unwrapLayoutTables(doc);

    // Remove all inline styles and classes
    doc.querySelectorAll('[style]').forEach(el => el.removeAttribute('style'));
    doc.querySelectorAll('[class]').forEach(el => el.removeAttribute('class'));

    // Convert orphan divs to paragraphs (divs with only inline content)
    doc.querySelectorAll('div').forEach(div => {
        const hasBlockChildren = div.querySelector('div, p, ul, ol, table, blockquote, h1, h2, h3, h4, h5, h6, section, article');
        if (!hasBlockChildren && div.textContent.trim()) {
            const p = doc.createElement('p');
            p.innerHTML = div.innerHTML;
            div.replaceWith(p);
        }
    });

    // Remove truly empty elements (no text, no images)
    doc.querySelectorAll('span, div, p, td, tr, table').forEach(el => {
        if (!el.textContent.trim() && !el.querySelector('img')) {
            el.remove();
        }
    });

    return doc.body.innerHTML;
}

function unwrapLayoutTables(doc) {
    // Process innermost tables first (bottom-up) to handle nesting
    let tables;
    let maxPasses = 10;
    while (maxPasses-- > 0) {
        tables = Array.from(doc.querySelectorAll('table'));
        if (tables.length === 0) break;

        let unwrapped = false;
        for (const table of tables) {
            // Skip tables that look like actual data tables
            if (isDataTable(table)) continue;

            // This is a layout table — unwrap it
            const frag = doc.createDocumentFragment();
            table.querySelectorAll(':scope > tbody > tr > td, :scope > tr > td').forEach(td => {
                // Move each cell's children out
                while (td.firstChild) {
                    frag.appendChild(td.firstChild);
                }
            });
            table.replaceWith(frag);
            unwrapped = true;
        }

        if (!unwrapped) break;
    }
}

function isDataTable(table) {
    // Has th elements = almost certainly a data table
    if (table.querySelector('th')) return true;

    const rows = table.querySelectorAll(':scope > tbody > tr, :scope > tr');
    if (rows.length < 2) return false;

    const colCounts = Array.from(rows).map(
        tr => tr.querySelectorAll(':scope > td, :scope > th').length
    );
    const maxCols = Math.max(...colCounts);

    // 1-2 column tables are almost always layout in email HTML.
    // Only consider 3+ column tables with consistent structure as data.
    if (maxCols < 3) return false;

    const allSame = colCounts.every(c => c === colCounts[0]);
    return allSame && rows.length >= 3;
}

function normalizeMSO(html, source) {
    let doc = new DOMParser().parseFromString(html, 'text/html');

    const walker = document.createTreeWalker(doc.body, NodeFilter.SHOW_COMMENT);
    const commentsToRemove = [];
    while (walker.nextNode()) {
        commentsToRemove.push(walker.currentNode);
    }
    commentsToRemove.forEach(c => c.parentNode.removeChild(c));

    doc.querySelectorAll('o\\:p').forEach(el => {
        while (el.firstChild) el.parentNode.insertBefore(el.firstChild, el);
        el.parentNode.removeChild(el);
    });

    doc.querySelectorAll('[style]').forEach(el => {
        const style = el.getAttribute('style');
        const cleaned = style.split(';')
            .filter(s => !s.trim().startsWith('mso-'))
            .join(';');
        if (cleaned.trim()) {
            el.setAttribute('style', cleaned);
        } else {
            el.removeAttribute('style');
        }
    });

    const listParas = doc.querySelectorAll('.MsoListParagraph, [class*="MsoList"]');
    if (listParas.length > 0) {
        convertMsoListsToReal(doc, listParas);
    }

    if (source === 'word') {
        for (let level = 1; level <= 6; level++) {
            doc.querySelectorAll(`.MsoHeading${level}, [class*="MsoHeading${level}"]`).forEach(el => {
                const heading = doc.createElement(`h${level}`);
                heading.innerHTML = el.innerHTML;
                el.parentNode.replaceChild(heading, el);
            });
        }
    }

    doc.querySelectorAll('[class]').forEach(el => el.removeAttribute('class'));
    doc.querySelectorAll('span').forEach(el => {
        if (!el.textContent.trim() && !el.querySelector('img')) {
            el.parentNode.removeChild(el);
        }
    });

    // Run generic email HTML cleaner to handle layout tables, tracking pixels, etc.
    // Safe for actual MSO content (only removes non-content elements)
    const cleaned = cleanEmailHtml(doc.body.innerHTML);
    const md = htmlToMarkdown(cleaned);
    return normalizeGeneral(md);
}

function convertMsoListsToReal(doc, listParas) {
    let currentList = null;
    let lastParent = null;

    listParas.forEach(para => {
        const text = para.textContent.trim();
        const isNumbered = /^\d+[.)]\s/.test(text) || /level\d.*decimal/i.test(para.getAttribute('style') || '');
        const listTag = isNumbered ? 'ol' : 'ul';

        const parent = para.parentNode;
        if (!currentList || lastParent !== parent || currentList.tagName.toLowerCase() !== listTag) {
            currentList = doc.createElement(listTag);
            parent.insertBefore(currentList, para);
            lastParent = parent;
        }

        const li = doc.createElement('li');
        let content = para.innerHTML;
        const tempDiv = doc.createElement('div');
        tempDiv.innerHTML = content;
        const firstText = tempDiv.firstChild;
        if (firstText && firstText.nodeType === 3) {
            firstText.textContent = firstText.textContent.replace(/^[\s\u00A0]*[•·○►▪▸‣–\-]\s*/, '');
            firstText.textContent = firstText.textContent.replace(/^[\s\u00A0]*\d+[.)]\s*/, '');
        }
        li.innerHTML = tempDiv.innerHTML;
        currentList.appendChild(li);
        parent.removeChild(para);
    });
}

function normalizeGmail(html) {
    let doc = new DOMParser().parseFromString(html, 'text/html');

    // Gmail-specific cleanup
    doc.querySelectorAll('.gmail_signature, [data-smartmail="gmail_signature"]').forEach(el => {
        el.parentNode.removeChild(el);
    });

    doc.querySelectorAll('[class*="gmail_"]').forEach(el => {
        el.removeAttribute('class');
    });

    // Run generic email HTML cleaner (handles layout tables, tracking pixels, etc.)
    const cleaned = cleanEmailHtml(doc.body.innerHTML);

    const md = htmlToMarkdown(cleaned);
    return normalizeGeneral(md);
}

function normalizePDF(text, opts = {}) {
    let r = text;

    // When input came from HTML conversion, skip structural passes that HTML already handled
    const fromHtml = opts.fromHtml || false;

    if (!fromHtml) {
        r = pdfStripHeadersFooters(r);
        r = pdfDetectColumns(r);
    }

    r = pdfDehyphenate(r);

    if (!fromHtml) {
        r = pdfDetectHeadings(r);
        r = pdfMergeLines(r);
        r = pdfDetectTables(r);
    }

    // Final cleanup
    r = normalizeGeneral(r);
    r = r.replace(/\n{3,}/g, '\n\n');
    return r.trim();
}

// --- PDF Pass 1: Strip page headers, footers, and page numbers ---
function pdfStripHeadersFooters(text) {
    const lines = text.split('\n');

    // Detect repeating lines (headers/footers): hash each line, find lines appearing 3+ times
    const lineCounts = {};
    for (const line of lines) {
        const trimmed = line.trim();
        if (trimmed.length > 0 && trimmed.length < 100) {
            lineCounts[trimmed] = (lineCounts[trimmed] || 0) + 1;
        }
    }
    const repeatingLines = new Set();
    for (const [line, count] of Object.entries(lineCounts)) {
        if (count >= 3) repeatingLines.add(line);
    }

    return lines.filter(line => {
        const trimmed = line.trim();
        // Isolated page numbers: just digits on their own line
        if (/^\s*\d{1,4}\s*$/.test(line)) return false;
        // "Page X of Y" patterns
        if (/^\s*page\s+\d+\s*(of\s+\d+)?\s*$/i.test(line)) return false;
        // "- X -" centered page numbers
        if (/^\s*[-–—]\s*\d+\s*[-–—]\s*$/.test(line)) return false;
        // Roman numeral page numbers on their own line
        if (/^\s*[ivxlcdm]+\s*$/i.test(line) && /^[ivxlcdm]+$/i.test(trimmed) && trimmed.length <= 6) return false;
        // Repeating header/footer lines
        if (repeatingLines.has(trimmed)) return false;
        return true;
    }).join('\n');
}

// --- PDF Pass 2: Column detection and deinterleaving ---
function pdfDetectColumns(text) {
    const lines = text.split('\n');
    if (lines.length < 10) return text;

    // Compute line length stats for non-empty lines
    const nonEmpty = lines.filter(l => l.trim().length > 0);
    if (nonEmpty.length < 10) return text;

    const lengths = nonEmpty.map(l => l.length);
    const median = lengths.slice().sort((a, b) => a - b)[Math.floor(lengths.length / 2)];

    // Suspect columns if median line length is 35-65 chars (typical column width)
    // and many lines break mid-sentence
    if (median < 35 || median > 65) return text;

    const midBreaks = nonEmpty.filter(l => {
        const t = l.trim();
        return t.length > 15 && !/[.!?:;]$/.test(t) && t.length <= median + 10;
    });
    if (midBreaks.length / nonEmpty.length < 0.4) return text;

    // Check for consistent "gap" in lines — spaces in the middle indicating two columns
    // Look for lines with 2+ spaces creating a split point
    const gapPositions = [];
    for (const line of nonEmpty) {
        const match = line.match(/\S {2,}\S/);
        if (match) {
            gapPositions.push(line.indexOf(match[0]) + match[0].indexOf('  '));
        }
    }

    if (gapPositions.length < nonEmpty.length * 0.3) return text; // Not enough lines have gaps

    // Find the most common gap position (column break point)
    const posCounts = {};
    for (const pos of gapPositions) {
        // Allow ±3 chars tolerance
        const bucket = Math.round(pos / 3) * 3;
        posCounts[bucket] = (posCounts[bucket] || 0) + 1;
    }
    const bestBucket = Object.entries(posCounts).sort((a, b) => b[1] - a[1])[0];
    if (!bestBucket || bestBucket[1] < gapPositions.length * 0.3) return text;

    const splitPos = parseInt(bestBucket[0]);

    // Split each line into left and right columns
    const leftCol = [];
    const rightCol = [];
    for (const line of lines) {
        if (line.length > splitPos + 2) {
            const left = line.substring(0, splitPos).trimEnd();
            const right = line.substring(splitPos).trimStart();
            leftCol.push(left);
            rightCol.push(right);
        } else {
            leftCol.push(line);
            rightCol.push('');
        }
    }

    // Reconstruct: all left column text, then all right column text
    return leftCol.join('\n') + '\n\n' + rightCol.filter(l => l.trim()).join('\n');
}

// --- PDF Pass 3: Dehyphenation ---
function pdfDehyphenate(text) {
    let r = text;
    // Dehyphenate: word-\nword → join (only simple hyphens, not en/em dashes)
    r = r.replace(/(\w)-\n\s*(\w)/g, '$1$2');
    return r;
}

// --- PDF Pass 4: Heading detection ---
function pdfDetectHeadings(text) {
    const lines = text.split('\n');
    const result = [];

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const trimmed = line.trim();
        const prev = i > 0 ? lines[i - 1] : '';
        const next = i < lines.length - 1 ? lines[i + 1] : '';

        // Setext-style underlines: === or ---
        if (i > 0 && /^={3,}\s*$/.test(trimmed)) {
            // Previous line is an h1
            result[result.length - 1] = '# ' + result[result.length - 1].trim();
            continue; // skip the underline
        }
        if (i > 0 && /^-{3,}\s*$/.test(trimmed) && result[result.length - 1] && result[result.length - 1].trim().length > 0) {
            result[result.length - 1] = '## ' + result[result.length - 1].trim();
            continue;
        }

        // Skip empty lines and list items
        if (!trimmed || /^[-*•·]\s/.test(trimmed) || /^\d+[.)]\s/.test(trimmed)) {
            result.push(line);
            continue;
        }

        // ALL CAPS lines → heading (if short enough and not just an abbreviation)
        if (trimmed.length >= 3 && trimmed.length < 80 &&
            trimmed === trimmed.toUpperCase() &&
            /[A-Z]{2,}/.test(trimmed) &&
            !/^[^a-zA-Z]*$/.test(trimmed) && // not all symbols/numbers
            !prev.trim()) { // preceded by blank line or start
            // Convert to title case
            const titleCase = trimmed.replace(/\w\S*/g, w =>
                w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()
            );
            result.push('## ' + titleCase);
            continue;
        }

        // Numbered section headers: "1.2 Introduction", "Chapter 3: Methods"
        if (/^(\d+\.)+\d*\s+\S/.test(trimmed) && trimmed.length < 80 && !/[.!?]$/.test(trimmed)) {
            if (!prev.trim() || i === 0) {
                result.push('## ' + trimmed);
                continue;
            }
        }
        if (/^chapter\s+\d+/i.test(trimmed) && trimmed.length < 80) {
            result.push('# ' + trimmed);
            continue;
        }

        // Short lines surrounded by blank lines, no trailing punctuation → heading
        if (trimmed.length > 0 && trimmed.length < 60 &&
            !/[.!?,;:]$/.test(trimmed) &&
            !prev.trim() &&
            (!next.trim() || !next) &&
            !/^[-*•·]\s/.test(trimmed) && !/^\d+[.)]\s/.test(trimmed)) {
            result.push('## ' + trimmed);
            continue;
        }

        result.push(line);
    }

    return result.join('\n');
}

// --- PDF Pass 5: Aggressive line merging ---
function pdfMergeLines(text) {
    const lines = text.split('\n');
    const merged = [];

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const trimmed = line.trim();
        const next = i < lines.length - 1 ? lines[i + 1] : null;
        const trimmedNext = next ? next.trim() : '';

        // Always push if no next line, or current line is empty
        if (!next || !trimmed) {
            merged.push(line);
            continue;
        }

        // Don't merge list items
        if (/^[-*•·]\s/.test(trimmed) || /^\d+[.)]\s/.test(trimmed)) {
            merged.push(line);
            continue;
        }
        // Don't merge if next line is a list item
        if (/^[-*•·]\s/.test(trimmedNext) || /^\d+[.)]\s/.test(trimmedNext)) {
            merged.push(line);
            continue;
        }

        // Don't merge headings (lines starting with #)
        if (/^#{1,6}\s/.test(trimmed) || /^#{1,6}\s/.test(trimmedNext)) {
            merged.push(line);
            continue;
        }

        // Don't merge if next line is empty
        if (!trimmedNext) {
            merged.push(line);
            continue;
        }

        // Current line very short — likely a heading or label, don't merge
        if (trimmed.length < 20) {
            merged.push(line);
            continue;
        }

        // Sentence ends + next starts uppercase = real paragraph break
        if (/[.!?]$/.test(trimmed) && /^[A-Z]/.test(trimmedNext)) {
            merged.push(line);
            continue;
        }

        // Colon/semicolon at end + uppercase next = structural break
        if (/[:;]$/.test(trimmed) && /^[A-Z]/.test(trimmedNext)) {
            merged.push(line);
            continue;
        }

        // Different indentation = structural break
        const indent = (line.match(/^(\s*)/) || ['', ''])[1].length;
        const nextIndent = (next.match(/^(\s*)/) || ['', ''])[1].length;
        if (Math.abs(indent - nextIndent) > 2) {
            merged.push(line);
            continue;
        }

        // Otherwise: merge (this is the aggressive part — most single newlines are layout artifacts)
        merged.push(trimmed + ' ' + trimmedNext);
        i++; // skip next line since we consumed it
    }

    return merged.join('\n');
}

// --- PDF Pass 6: Table detection from whitespace-aligned columns ---
function pdfDetectTables(text) {
    const lines = text.split('\n');
    const result = [];
    let i = 0;

    while (i < lines.length) {
        // Look for blocks of lines with consistent multi-space separators
        const tableLines = [];
        let j = i;

        while (j < lines.length) {
            const line = lines[j];
            const trimmed = line.trim();
            if (!trimmed) {
                if (tableLines.length > 0) break; // end of potential table block
                j++;
                continue;
            }
            // Check for 2+ columns separated by 2+ spaces
            const parts = trimmed.split(/\s{2,}/).filter(p => p.trim());
            if (parts.length >= 2) {
                tableLines.push({ line: trimmed, parts, index: j });
                j++;
            } else {
                break;
            }
        }

        // Need at least 3 rows with consistent column count to be a table
        if (tableLines.length >= 3) {
            const colCounts = tableLines.map(t => t.parts.length);
            const modeCount = colCounts.sort((a, b) =>
                colCounts.filter(v => v === b).length - colCounts.filter(v => v === a).length
            )[0];

            // Check that most rows have the same column count
            const consistent = tableLines.filter(t => t.parts.length === modeCount);
            if (consistent.length >= tableLines.length * 0.7 && modeCount >= 2) {
                // Build markdown table from consistent rows
                const rows = consistent.map(t => {
                    const cells = t.parts.slice(0, modeCount);
                    while (cells.length < modeCount) cells.push('');
                    return cells.map(c => c.replace(/\|/g, '\\|'));
                });
                result.push(buildMarkdownTable(rows));
                i = j;
                continue;
            }
        }

        // Not a table — push the line as-is
        result.push(lines[i]);
        i++;
    }

    return result.join('\n');
}

function normalizeExcel(html, plain) {
    if (html && /<table[\s>]/i.test(html)) {
        const doc = new DOMParser().parseFromString(html, 'text/html');
        const table = doc.querySelector('table');
        if (table) {
            return tableElementToMarkdown(table);
        }
    }

    if (plain) {
        return tsvToMarkdownTable(plain);
    }

    return normalizeGeneral(plain || '');
}

function tableElementToMarkdown(table) {
    const rows = [];
    table.querySelectorAll('tr').forEach(tr => {
        const cells = [];
        tr.querySelectorAll('td, th').forEach(cell => {
            cells.push(cell.textContent.trim().replace(/\|/g, '\\|'));
        });
        rows.push(cells);
    });
    return buildMarkdownTable(rows);
}

function tsvToMarkdownTable(text) {
    const lines = text.trim().split('\n').filter(l => l.trim());
    if (lines.length < 1) return text;

    const rows = lines.map(line => line.split('\t').map(cell => cell.trim().replace(/\|/g, '\\|')));

    const colCounts = rows.map(r => r.length);
    const maxCols = Math.max(...colCounts);
    if (maxCols < 2) return normalizeGeneral(text);

    const padded = rows.map(r => {
        while (r.length < maxCols) r.push('');
        return r;
    });

    return buildMarkdownTable(padded);
}

function buildMarkdownTable(rows) {
    if (rows.length === 0) return '';

    const header = rows[0];
    const separator = header.map(() => '---');
    const dataRows = rows.slice(1);

    const lines = [];
    lines.push('| ' + header.join(' | ') + ' |');
    lines.push('| ' + separator.join(' | ') + ' |');
    dataRows.forEach(row => {
        lines.push('| ' + row.join(' | ') + ' |');
    });

    return lines.join('\n');
}

function normalizeMarkdownInput(text) {
    let r = text;
    r = r.replace(/^(\s*)[*+]\s/gm, '$1- ');
    r = r.replace(/^(#{1,6})([^\s#])/gm, '$1 $2');
    return normalizeGeneral(r);
}

// ============================================================================
// UTILITIES
// ============================================================================

function hasSignificantHtml(html) {
    if (!html || !html.trim()) return false;
    // Check if the HTML has real structure beyond just a plain-text wrapper
    const tagCount = (html.match(/<(p|div|table|ul|ol|li|h[1-6]|blockquote|br|a|strong|em|b|i|span)\b/gi) || []).length;
    return tagCount >= 3;
}

function fixMojibake(text) {
    let result = text;

    const threeByteMap = [
        ['\u00E2\u20AC\u201D', '\u2014'],
        ['\u00E2\u20AC\u201C', '\u2013'],
        ['\u00E2\u20AC\u2122', '\u2019'],
        ['\u00E2\u20AC\u02DC', '\u2018'],
        ['\u00E2\u20AC\u0153', '\u201C'],
        ['\u00E2\u20AC\u009D', '\u201D'],
        ['\u00E2\u20AC\u00A2', '\u2022'],
        ['\u00E2\u20AC\u00A6', '\u2026'],
        ['\u00E2\u201A\u00B9', '\u20B9'],
        ['\u00E2\u201A\u00AC', '\u20AC'],
    ];

    const twoByteMap = [
        ['\u00C2\u00A3', '\u00A3'],
        ['\u00C2\u00A9', '\u00A9'],
        ['\u00C2\u00AE', '\u00AE'],
        ['\u00C2\u00B0', '\u00B0'],
        ['\u00C2\u00B7', '\u00B7'],
        ['\u00C2\u00BD', '\u00BD'],
        ['\u00C2\u00A0', ' '],
        ['\u00C3\u00A9', '\u00E9'],
        ['\u00C3\u00A8', '\u00E8'],
        ['\u00C3\u00BC', '\u00FC'],
        ['\u00C3\u00B6', '\u00F6'],
        ['\u00C3\u00A4', '\u00E4'],
        ['\u00C3\u00B1', '\u00F1'],
    ];

    for (const [bad, good] of threeByteMap) {
        result = result.split(bad).join(good);
    }
    for (const [bad, good] of twoByteMap) {
        result = result.split(bad).join(good);
    }

    result = result.replace(/\u00E2\u20AC(?=[,.\s\n;:!?)\]]|$)/gm, '\u201D');

    return result;
}

function htmlToMarkdown(html) {
    const td = new TurndownService({
        headingStyle: 'atx',
        codeBlockStyle: 'fenced',
        bulletListMarker: '-',
        emDelimiter: '*',
    });

    if (typeof turndownPluginGfm !== 'undefined') {
        td.use(turndownPluginGfm.gfm);
    }

    td.remove(['script', 'style']);

    return td.turndown(html);
}

function countChanges(original, cleaned) {
    let changes = 0;
    const a = original, b = cleaned;
    const maxLen = Math.max(a.length, b.length);
    let inDiff = false;
    for (let i = 0; i < maxLen; i++) {
        if (a[i] !== b[i]) {
            if (!inDiff) { changes++; inDiff = true; }
        } else {
            inDiff = false;
        }
    }
    return changes;
}

// ============================================================================
// OUTPUT FORMATTERS
// ============================================================================

function formatMarkdown(md) {
    return { text: md, html: null, copyMode: 'text' };
}

function formatGmail(md) {
    let html = marked.parse(md, { breaks: false, gfm: true });

    const font = getSelectedFont('Arial,sans-serif');
    const size = getSelectedSize('14px');
    const baseFont = `font-family:${font};font-size:${size};`;
    html = html
        .replace(/<p>/g, `<p style="margin:0 0 10px 0;${baseFont}line-height:1.5;color:#222;">`)
        .replace(/<ul>/g, `<ul style="margin:0 0 10px 0;padding-left:24px;${baseFont}">`)
        .replace(/<ol>/g, `<ol style="margin:0 0 10px 0;padding-left:24px;${baseFont}">`)
        .replace(/<li>/g, '<li style="margin:0 0 4px 0;">')
        .replace(/<h1>/g, `<h1 style="margin:0 0 8px 0;font-family:${font};font-size:22px;font-weight:bold;color:#222;">`)
        .replace(/<h2>/g, `<h2 style="margin:0 0 8px 0;font-family:${font};font-size:18px;font-weight:bold;color:#222;">`)
        .replace(/<h3>/g, `<h3 style="margin:0 0 6px 0;font-family:${font};font-size:16px;font-weight:bold;color:#222;">`)
        .replace(/<blockquote>/g, `<blockquote style="border-left:3px solid #ccc;padding-left:12px;margin:0 0 10px 0;color:#555;${baseFont}">`)
        .replace(/<code>/g, '<code style="background:#f0f0f0;padding:2px 4px;border-radius:3px;font-family:monospace;font-size:13px;">')
        .replace(/<pre>/g, '<pre style="background:#f0f0f0;padding:12px;border-radius:4px;overflow-x:auto;margin:0 0 10px 0;font-family:monospace;font-size:13px;">')
        .replace(/<table>/g, `<table style="border-collapse:collapse;margin:0 0 10px 0;${baseFont}">`)
        .replace(/<th>/g, '<th style="border:1px solid #ccc;padding:6px 10px;background:#f5f5f5;font-weight:600;text-align:left;">')
        .replace(/<td>/g, '<td style="border:1px solid #ccc;padding:6px 10px;text-align:left;">');

    return { text: md, html: html, copyMode: 'rich' };
}

// Returns selected font, or the app-specific default if "Match app default"
function getSelectedFont(appDefault) {
    return document.getElementById('font-family').value || appDefault;
}

// Returns selected size, or empty string if "Match app default"
// For Outlook/Gmail, we need an explicit size. For Word, empty = inherit.
function getSelectedSize(appDefault) {
    return document.getElementById('font-size').value || appDefault;
}

function formatOutlook(md) {
    let html = marked.parse(md, { breaks: false, gfm: true });

    const font = getSelectedFont('Calibri,sans-serif');
    const size = getSelectedSize('11pt');
    const baseFont = `font-family:${font};font-size:${size};color:#000;`;
    html = html
        .replace(/<p>/g, `<p style="margin:0 0 8pt 0;${baseFont}line-height:1.4;">`)
        .replace(/<ul>/g, `<ul style="margin:0 0 8pt 0;padding-left:36px;${baseFont}">`)
        .replace(/<ol>/g, `<ol style="margin:0 0 8pt 0;padding-left:36px;${baseFont}">`)
        .replace(/<li>/g, '<li style="margin:0 0 3pt 0;">')
        .replace(/<h1>/g, `<h1 style="margin:0 0 6pt 0;font-family:${font};font-size:16pt;font-weight:bold;color:#000;">`)
        .replace(/<h2>/g, `<h2 style="margin:0 0 6pt 0;font-family:${font};font-size:14pt;font-weight:bold;color:#000;">`)
        .replace(/<h3>/g, `<h3 style="margin:0 0 4pt 0;font-family:${font};font-size:12pt;font-weight:bold;color:#000;">`)
        .replace(/<blockquote>/g, `<div style="border-left:3px solid #ccc;padding-left:12px;margin:0 0 8pt 0;color:#555;${baseFont}">`)
        .replace(/<\/blockquote>/g, '</div>')
        .replace(/<code>/g, '<code style="background:#f0f0f0;padding:1px 4px;border-radius:2px;font-family:Consolas,monospace;font-size:10pt;">')
        .replace(/<pre>/g, '<pre style="background:#f0f0f0;padding:10px;border-radius:4px;overflow-x:auto;margin:0 0 8pt 0;font-family:Consolas,monospace;font-size:10pt;">')
        .replace(/<table>/g, `<table style="border-collapse:collapse;margin:0 0 8pt 0;${baseFont}">`)
        .replace(/<th>/g, '<th style="border:1px solid #999;padding:4px 8px;background:#f0f0f0;font-weight:bold;text-align:left;">')
        .replace(/<td>/g, '<td style="border:1px solid #999;padding:4px 8px;text-align:left;">');

    return { text: md, html: html, copyMode: 'rich' };
}

function formatWord(md) {
    let html = marked.parse(md, { breaks: false, gfm: true });

    const font = getSelectedFont('Calibri,sans-serif');
    const size = getSelectedSize('');
    // Build base font: always include font-family (without it Word uses Times
    // New Roman). Only include font-size if user explicitly selected one —
    // empty means "match document default".
    const baseFont = `font-family:${font};` + (size ? `font-size:${size};` : '');
    html = html
        .replace(/<p>/g, `<p style="${baseFont}">`)
        .replace(/<ul>/g, `<ul style="${baseFont}">`)
        .replace(/<ol>/g, `<ol style="${baseFont}">`)
        .replace(/<h1>/g, `<h1 style="font-family:${font};">`)
        .replace(/<h2>/g, `<h2 style="font-family:${font};">`)
        .replace(/<h3>/g, `<h3 style="font-family:${font};">`)
        .replace(/<blockquote>/g, `<div style="border-left:3px solid #ccc;padding-left:12px;margin:0 0 8pt 0;color:#555;${baseFont}">`)
        .replace(/<\/blockquote>/g, '</div>')
        .replace(/<code>/g, '<code style="font-family:Consolas,monospace;">')
        .replace(/<pre>/g, '<pre style="background:#f0f0f0;padding:10px;font-family:Consolas,monospace;">')
        .replace(/<table>/g, `<table style="border-collapse:collapse;${baseFont}">`)
        .replace(/<th>/g, '<th style="border:1px solid #bbb;padding:4px 8px;font-weight:bold;">')
        .replace(/<td>/g, '<td style="border:1px solid #bbb;padding:4px 8px;">');

    return { text: md, html: html, copyMode: 'rich' };
}

function formatWhatsApp(md) {
    let text = md;

    // Convert headings to *bold* lines
    text = text.replace(/^#{1,6}\s+(.+)$/gm, '*$1*');

    // Convert bold: **text** or __text__ → *text*
    text = text.replace(/\*\*(.+?)\*\*/g, '*$1*');
    text = text.replace(/__(.+?)__/g, '*$1*');

    // Convert italic: *text* or _text_ → _text_
    // Must run after bold conversion. Match single * not preceded/followed by *
    text = text.replace(/(?<!\*)\*(?!\*)(.+?)(?<!\*)\*(?!\*)/g, '_$1_');

    // Convert strikethrough: ~~text~~ → ~text~
    text = text.replace(/~~(.+?)~~/g, '~$1~');

    // Convert inline code: `text` → ```text```
    // But leave fenced code blocks alone
    text = text.replace(/(?<!`)``(?!`)(.+?)(?<!`)``(?!`)/g, '```$1```');
    text = text.replace(/(?<!`)`(?!`)(.+?)(?<!`)`(?!`)/g, '```$1```');

    // Convert links: [text](url) → text (url)
    text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '$1 ($2)');

    // Convert images: ![alt](url) → [Image: alt]
    text = text.replace(/!\[([^\]]*)\]\([^)]+\)/g, (_, alt) => alt ? `[Image: ${alt}]` : '');

    // Convert blockquotes: > text → (keep as-is, WhatsApp doesn't have quotes)
    // Just remove the > prefix
    text = text.replace(/^>\s?/gm, '');

    // Convert horizontal rules
    text = text.replace(/^[-*_]{3,}$/gm, '———');

    // Clean up multiple blank lines
    text = text.replace(/\n{3,}/g, '\n\n');

    return { text: text.trim(), html: null, copyMode: 'text' };
}

// ============================================================================
// PIPELINE
// ============================================================================

function runPipeline() {
    const inputEl = document.getElementById('input');
    const plain = inputEl.value;
    const stats = document.getElementById('stats');

    if (!plain.trim() && !pastedHTML.trim()) {
        intermediateMarkdown = '';
        formattedOutput = '';
        formattedHTML = '';
        document.getElementById('output-text').value = '';
        document.getElementById('output-html').innerHTML = '';
        document.getElementById('output-text').classList.remove('hidden');
        document.getElementById('output-html-wrap').classList.add('hidden');
        document.getElementById('output-hint').classList.add('hidden');
        stats.classList.add('hidden');
        hideSuggestionBanner();
        return;
    }

    switch (currentInputMode) {
        case 'outlook':
            intermediateMarkdown = pastedHTML
                ? normalizeMSO(pastedHTML, 'outlook')
                : normalizeGeneral(plain);
            break;
        case 'word':
            intermediateMarkdown = pastedHTML
                ? normalizeMSO(pastedHTML, 'word')
                : normalizeGeneral(plain);
            break;
        case 'gmail':
            intermediateMarkdown = pastedHTML
                ? normalizeGmail(pastedHTML)
                : normalizeGeneral(plain);
            break;
        case 'pdf':
            if (pastedHTML && hasSignificantHtml(pastedHTML)) {
                // Browser PDF viewers sometimes produce structured HTML — use it
                const cleaned = cleanEmailHtml(pastedHTML);
                const md = htmlToMarkdown(cleaned);
                intermediateMarkdown = normalizePDF(md, { fromHtml: true });
            } else {
                intermediateMarkdown = normalizePDF(plain);
            }
            break;
        case 'excel':
            intermediateMarkdown = normalizeExcel(pastedHTML, plain);
            break;
        case 'markdown':
            intermediateMarkdown = normalizeMarkdownInput(plain);
            break;
        default:
            intermediateMarkdown = (pastedHTML && hasSignificantHtml(pastedHTML))
                ? normalizeHtmlGeneral(pastedHTML)
                : normalizeGeneral(plain);
    }

    // Auto-detect: always run on paste, suggest if detected source differs
    // from current input mode (not just when in General mode)
    if (!suggestionDismissed) {
        const detected = detectSource(pastedHTML, plain);
        if (detected && detected !== currentInputMode) {
            showSuggestionBanner(detected);
        } else {
            hideSuggestionBanner();
        }
    }

    const changeCount = countChanges(plain, intermediateMarkdown);
    stats.classList.remove('hidden');
    document.getElementById('stat-mode').textContent = `Source: ${INPUT_LABELS[currentInputMode]}`;
    document.getElementById('stat-changes').textContent = changeCount > 0
        ? `${changeCount} fix${changeCount === 1 ? '' : 'es'} applied`
        : 'No changes needed';

    renderOutput();
}

function renderOutput() {
    const outputText = document.getElementById('output-text');
    const outputHtmlWrap = document.getElementById('output-html-wrap');
    const outputHtml = document.getElementById('output-html');
    const hint = document.getElementById('output-hint');
    const copyBtn = document.getElementById('btn-copy');

    if (!intermediateMarkdown) return;

    let result;
    switch (currentOutputMode) {
        case 'outlook':
            result = formatOutlook(intermediateMarkdown);
            break;
        case 'gmail':
            result = formatGmail(intermediateMarkdown);
            break;
        case 'word':
            result = formatWord(intermediateMarkdown);
            break;
        case 'whatsapp':
            result = formatWhatsApp(intermediateMarkdown);
            break;
        default:
            result = formatMarkdown(intermediateMarkdown);
    }

    formattedOutput = result.text;
    formattedHTML = result.html || '';

    if (result.copyMode === 'rich') {
        outputText.classList.add('hidden');
        outputHtmlWrap.classList.remove('hidden');
        outputHtml.innerHTML = formattedHTML;
        hint.classList.remove('hidden');
        hint.textContent = `Preview \u2014 Copy puts formatted HTML on your clipboard for ${OUTPUT_LABELS[currentOutputMode]}.`;
        copyBtn.textContent = `Copy for ${OUTPUT_LABELS[currentOutputMode]}`;
    } else {
        outputText.classList.remove('hidden');
        outputHtmlWrap.classList.add('hidden');
        outputText.value = formattedOutput;
        hint.classList.add('hidden');
        copyBtn.textContent = 'Copy';
    }
}

// ============================================================================
// CLIPBOARD
// ============================================================================

async function copyOutput() {
    if (formattedHTML && currentOutputMode !== 'markdown') {
        try {
            const htmlBlob = new Blob([formattedHTML], { type: 'text/html' });
            const textBlob = new Blob([formattedOutput], { type: 'text/plain' });
            await navigator.clipboard.write([
                new ClipboardItem({
                    'text/html': htmlBlob,
                    'text/plain': textBlob,
                })
            ]);
            showCopyFeedback(`Copied for ${OUTPUT_LABELS[currentOutputMode]}!`);
        } catch (err) {
            await navigator.clipboard.writeText(formattedHTML);
            showCopyFeedback('Copied HTML');
        }
    } else {
        const text = document.getElementById('output-text').value;
        if (!text) return;
        await navigator.clipboard.writeText(text);
        showCopyFeedback('Copied!');
    }
}

function showCopyFeedback(message) {
    const btn = document.getElementById('btn-copy');
    const original = btn.textContent;
    btn.textContent = message;
    btn.classList.add('copy-flash');
    setTimeout(() => {
        btn.textContent = original;
        btn.classList.remove('copy-flash');
    }, 1500);
}

function clearAll() {
    document.getElementById('input').value = '';
    pastedHTML = '';
    pastedPlain = '';
    intermediateMarkdown = '';
    formattedOutput = '';
    formattedHTML = '';
    suggestedMode = null;
    suggestionDismissed = false;
    hideSuggestionBanner();
    runPipeline();
}

// ============================================================================
// PASTE COUNTER (localStorage)
// ============================================================================

function getPasteStats() {
    try {
        return JSON.parse(localStorage.getItem('pasteclean-stats') || '{}');
    } catch { return {}; }
}

function incrementPasteCounter() {
    const stats = getPasteStats();
    stats.pastes = (stats.pastes || 0) + 1;
    localStorage.setItem('pasteclean-stats', JSON.stringify(stats));
    renderPasteCounter();
}

function renderPasteCounter() {
    const stats = getPasteStats();
    const el = document.getElementById('paste-counter');
    const count = stats.pastes || 0;
    if (count === 0) {
        el.textContent = '';
    } else {
        el.textContent = `${count.toLocaleString()} paste${count === 1 ? '' : 's'} cleaned`;
    }
}

// ============================================================================
// INIT
// ============================================================================

const inputEl = document.getElementById('input');

inputEl.addEventListener('paste', (e) => {
    const clipboardData = e.clipboardData || window.clipboardData;
    if (clipboardData) {
        pastedHTML = clipboardData.getData('text/html') || '';
        pastedPlain = clipboardData.getData('text/plain') || '';
    }
    // Reset suggestion state on every new paste so auto-detect runs fresh
    suggestionDismissed = false;
    suggestedMode = null;
    incrementPasteCounter();
    setTimeout(() => {
        runPipeline();
    }, 10);
});

inputEl.addEventListener('input', () => {
    // If input was cleared, reset HTML state so stale data doesn't linger
    if (!inputEl.value.trim()) {
        pastedHTML = '';
        pastedPlain = '';
        suggestionDismissed = false;
        suggestedMode = null;
    }
    runPipeline();
});

applyOutputConstraints();
updateThemeIcons();
renderPasteCounter();
</script>
<script data-goatcounter="https://coderkuttappan.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
</body>
</html>
